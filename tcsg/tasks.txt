1
Реверс строки

Необходимо реализовать функцию reverse, которая должна переворачивает строку.

Пример

привет, мир -> `рим ,тевирп`


package main

import (
	"fmt"
	"io"
	"os"
	"strings"
)

func reverse(s string) string {
	if len(s) <= 1 {
		return s
	}

	arr := make([]byte, len(s))

	for i, j := 0, len(s)-1; i < j; {
		arr[i], arr[j] = s[j], s[i]
		i++
		j--
	}
	return string(arr)
}

func main() {
	b, _ := io.ReadAll(os.Stdin)
	str := strings.Trim(string(b), "\n")

	result := reverse(str)

	fmt.Fprintln(os.Stdout, result)
}

тест упал - проблемы с юникодом

привет, мир

===========
2
Сжатие самоизолирующихся последовательностей 📉

Необходимо написать функцию, которая будет принимать на вход массив чисел и возвращать сжатые последовательности в виде массива кортежей.

Ограничения

Функция должна принимать на вход массив чисел.
Функция должна возвращать массив кортежей с числами.
Каждый элемент кортежа должен удовлетворять формату - (x, y)
x - число из последовательности.
y - количество раз, которое это число встречается в последовательности.
Пример

Входные параметры:

1, 2, 2, 3, 4, 3, 3, 3
Выходные:

(1, 1), (2, 2), (3, 1), (4, 1), (3, 3)

--
package main

import (
	"fmt"
	"io"
	"os"
)

func main() {
	b, _ := io.ReadAll(os.Stdin)

	// solution

	fmt.Fprintln(os.Stdout, result)
}

====
3

Панграммы 📝

Необходимо написать функцию, определяющую, является ли предложение панграммой.

Панграмма - это предложение, которое содержит каждую отдельную букву алфавита по крайней мере один раз.

Например, предложение:

Любя, съешь щипцы, — вздохнёт мэр, — кайф жгуч.
является панграммой, потому что в нем используются все буквы алфавита от А до Я по крайней мере один раз.

Ограничения

Функция должна принимать на вход строку;
Функция должна возвращать строку с булевым значением (True|False, см. пример) соответственно тому, является текст панграммой или нет;
Регистр букв не должен учитываться;
Все символы кроме кириллицы должны игнорироваться.
Пример

Входные параметры:

Любя, съешь щипцы, — вздохнёт мэр, — кайф жгуч.
Выходные параметры:

True

--

package main

import (
	"fmt"
	"io"
	"os"
)

func is_pangram(s string) string {
	// solution
}

func main() {
	b, _ := io.ReadAll(os.Stdin)

	result := is_pangram(string(b))

	fmt.Fprintln(os.Stdout, result)
}

===
4
5 букв 🎯

Необходимо написать функцию, которая проверяет правильность решения для игры 5 букв.

Ограничения

Функция принимает строкой ответ пользователя и правильный ответ, разделенные запятой (см. пример);
Функция должна возвращать массив из 5 элементов в виде строки
Каждый элемент - это цифра отвечающая за сопадения

-1: Буква отсутствует

0: Буква есть, но в другом месте

1: Буква на своём месте
Слова должны состоять строго из 5 букв без символов;
При проверке повторяющихся букв должно учитываться их количество. Например, если в ответе "ТЕКСТ" есть только одна буква Е, а пользователь отправил слово "ЕГЕРЬ", то только одна буква Е должна быть помечена как 0, 
остальные должны быть -1.
Пример

Входные параметры:

ДОЖДЬ, ДЗЮДО
Выходные:

1, 0, -1, 1, -1

--
package main

import (
	"fmt"
	"io"
	"os"
)

func get_answer_mask(s string) string {
	// solution
}

func main() {
	b, _ := io.ReadAll(os.Stdin)

	result := get_answer_mask(string(b))

	fmt.Fprintln(os.Stdout, result)
}

===
5
JSON

На вход программе в Stdin подается неструктурированный масив данных пользователей, платежей и адресов. Все данные находятся в одном массиве. Требуется реализовать программу, которая будет в stdout возвращать 
структурированный JSON с массивом всех пользователей. У всех пользователей должен быть массив платежей и адресов, в котором должны находиться соответствующие записи из исходного массива.

Полученный массив необходимо вывести в Stdout.

Описание входного JSON
{
  "data": [
    {
      "type": "user",      // user|payment|address - тип записи
      "id": 1,             // идентификатор конкретной сущности
      "firstname": "Alex"  // имя пользователя
    },
    {
      "type": "payment",   // тип платежа
      "id": 1,             // id платежа
      "user": 1,           // id пользователя, к которому относится платеж
      "amount": 10         // количество
    },
    {
      "type": "user",
      "id": 1,
      "lastname": "John"   // фамилия пользователя
    },
    {
      "user": 1,           // id пользователя, к которому относится адрес
      "type": "address",
      "id": 1,             // id адреса
      "address": "NY"      // адрес
    }
  ]
}
Ограничения

В входном массиве пользователи могут повторяться, в таком случае нужно объеденить данных из двух записей. Например:

{ "data": [ { "type": "user", "id": 1, "firstname": "Alex" }, { "type": "user", "id": 1, "lastname": "John" }, ] }

Должно стать:

[ { "id": 1, "firstname": "Alex", "lastname": "John", "payments": [], "addresses": [] } ]
Платежи и адреса во входном массиве повторяться не могут.
Повторяться id могут только у сущности user, что будет означать необходимость объеденить структуры. При этом у двух структур одного пользователя не могут пересекаться firstname или lastname, если есть firstname у 
одной структуры, у второй его точно не будет.
Пример

Входные данные:
{
  "data": [
    {
      "type": "user",
      "id": 1,
      "firstname": "Alex"
    },
    {
      "type": "payment",
      "id": 1,
      "user": 1,
      "amount": 10
    },
    {
      "type": "user",
      "id": 1,
      "lastname": "John"
    },
    {
      "user": 1,
      "type": "address",
      "id": 1,
      "address": "NY"
    }
  ]
}
Выходные данные:
[
 {
  "id": 1,
  "firstname": "Alex",
  "lastname": "John",
  "payments": [
   {
    "id": 1,
    "amount": 10
   }
  ],
  "addresses": [
   {
    "id": 1,
    "address": "NY"
   }
  ]
 }
]
---
package main

import (
	"encoding/json"
	"fmt"
	"log"
	"os"
)

type Data struct {
	Data []interface{} `json:"data"`
}

func main() {
	var result Data
	err := json.NewDecoder(os.Stdin).Decode(&result)
	if err != nil {
		log.Fatal(err)
	}

    // solution

	var userSlice []User
	for _, user := range users {
		userSlice = append(userSlice, *user)
	}

	bytes, _ := json.MarshalIndent(userSlice, "", " ")

	fmt.Fprintln(os.Stdout, string(bytes))
}


==
6
Помоги буквам найти свою пару 💛

Написать функцию, которая находит все уникальные символьные комбинации из заданной строки.
Например, для строки "abc" уникальные комбинации будут: "a", "ab", "abc", "ac", "acb", "b", "ba", "bac", "bc", "bca", "c", "ca", "cab", "cb", "cba".

Ограничения

Функция должна принимать на вход строку, для которой нужно найти уникальные комбинации;
Функция должна возвращать строку с массивом всех уникальных комбинаций в заданной строке, разделенные запятой (см. пример).
Пример

Входные параметры:

abc
Выходные:

a, ab, abc, ac, acb, b, ba, bac, bc, bca, c, ca, cab, cb, cba

--
package main

import (
	"fmt"
	"io"
	"os"
)

func find_combinations(s string) string {
	// solution
}

func main() {
	b, _ := io.ReadAll(os.Stdin)

	result := find_combinations(string(b))

	fmt.Fprintln(os.Stdout, result)
}

===
7
Свечи

Необходимо сгенерировать из цен
свечи https://ru.wikipedia.org/wiki/Японские_свечи#Форма_«японских_свечей»
 по интервалам: 1 минута(1min), 2 минуты(2min) и 5 минут(5min).

Свеча агрегирует в себе цены на своем интервале. Например, для диапазона цен от 18:03:14 до 18:17:50 будет 4 пятиминутные свечи:

18:00:00 (все цены с временем 18:00:00 <= ts < 18:05:00)
18:05:00 (все цены с временем 18:05:00 <= ts < 18:10:00)
18:10:00 (все цены с временем 18:10:00 <= ts < 18:15:00)
18:15:00 (все цены с временем 18:15:00 <= ts < 18:20:00)
И 8 двухминутных свечей:

18:02:00 (все цены с временем 18:02:00 <= ts < 18:04:00)
18:04:00 (все цены с временем 18:04:00 <= ts < 18:06:00)
...
18:14:00 (все цены с временем 18:14:00 <= ts < 18:16:00)
18:16:00 (все цены с временем 18:16:00 <= ts < 18:18:00)
Если за какой-то интевал цен нет, то этот интервал для данного идентификатора остается пустым. Пример: если для идентификатора TSLA есть цены в интервале [18:00:00, 18:00:59] и [18:02:00, 18:02:59], то у него 
должно быть только двухминутные свечи с временем 18:00:00 и 18:02:00.

Входные данные

На вход подается файл с ценами по нескольким инструментам следующего вида: Идентификатор_инструмента,цена,время(в формате rfc3339). Разделителем является запятая.
Входные данные отсортированы по времени в порядке возрастания.
TSLA,191.97,2023-04-11T12:04:30Z
TCSG,32.49,2023-04-11T12:04:30Z
Выходные данные

Формат свечи: Идентификатор_инструмента,цена_открытия,максимальная_цена,минимальная_цена,цена_закрытия,время(в формате rfc3339, кратное интервалу),интервал. Разделителем является запятая.
Свечи в выводе отсортированы сначала по идентификаторам, внутри идентификатора - по интервалам, а внутри интервала отсортированы по времени.
Время свечи должно быть кратно интервалу. Пример: время цены 18:01:35 -> время одноминутной свечи 18:01:00. Для округления времени вниз по интервалу свечи можно воспользоваться методом Truncate()
Ограничения

Важно не забыть выгрузить последние, не закрытые свечи.
Пример

Input

TSLA,191.97,2023-04-11T12:04:30Z
TCSG,32.49,2023-04-11T12:04:30Z
TSLA,192.50,2023-04-11T12:05:15Z
TCSG,32.17,2023-04-11T12:05:15Z
TSLA,191.30,2023-04-11T12:05:53Z
TCSG,31.84,2023-04-11T12:05:53Z
TSLA,191.60,2023-04-11T12:06:39Z
TCSG,31.53,2023-04-11T12:06:39Z
Output

TCSG,32.49,32.49,32.49,32.49,2023-04-11T12:04:00Z,1min
TCSG,32.17,32.17,31.84,31.84,2023-04-11T12:05:00Z,1min
TCSG,31.53,31.53,31.53,31.53,2023-04-11T12:06:00Z,1min
TCSG,32.49,32.49,31.84,31.84,2023-04-11T12:04:00Z,2min
TCSG,31.53,31.53,31.53,31.53,2023-04-11T12:06:00Z,2min
TCSG,32.49,32.49,32.49,32.49,2023-04-11T12:00:00Z,5min
TCSG,32.17,32.17,31.53,31.53,2023-04-11T12:05:00Z,5min
TSLA,191.97,191.97,191.97,191.97,2023-04-11T12:04:00Z,1min
TSLA,192.50,192.50,191.30,191.30,2023-04-11T12:05:00Z,1min
TSLA,191.60,191.60,191.60,191.60,2023-04-11T12:06:00Z,1min
TSLA,191.97,192.50,191.30,191.30,2023-04-11T12:04:00Z,2min
TSLA,191.60,191.60,191.60,191.60,2023-04-11T12:06:00Z,2min
TSLA,191.97,191.97,191.97,191.97,2023-04-11T12:00:00Z,5min
TSLA,192.50,192.50,191.30,191.60,2023-04-11T12:05:00Z,5min

---
package main

import (
    "bufio"
    "encoding/csv"
    "log"
    "os"
)

func main() {
    scanner := bufio.NewScanner(os.Stdin)

    for scanner.Scan() {
        // solution
    }

    // solution

    w := csv.NewWriter(os.Stdout)
    w.Comma = ','
    defer w.Flush()

    for _, candle := range candles {
        if err := w.Write(candle.ToCSV()); err != nil {
            log.Fatal(err)
        }
    }
}

==Y

